---
title: "linear forest Covid-19"
author: "Marlin"
date: "2023-01-04"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r data prep}
library(DSIWastewater)
library(dplyr)
library(ggplot2)
library(tidyr)
library(randomForest)
data(WasteWater_data, package = "DSIWastewater")
data(Case_data, package = "DSIWastewater")
data(pop_data, package = "DSIWastewater")

base_df <- inner_join(Case_data, WasteWater_data, by = c("site", "date"))%>%
  left_join(pop_data)%>%
  group_by(site)%>%
  arrange(date)%>%
  mutate(conf_case = zoo::rollmean(conf_case, 7, align = "center", na.pad = TRUE))%>%
  ungroup()%>%
  select(conf_case, N1, N2,
         regions, date, pop,
         PMMoV, flow,
         conductivity, temperature, ph, tests)%>%
   mutate(regions = factor(regions), date = as.numeric(date),
         conf_case = log(conf_case),
         N1 = log(N1),
         N2 = log(N2),
         PMMoV = log(PMMoV))
#conductivity, temperature, ph, tests

base_df%>%
  na.roughfix(base_df)%>%
  dplyr::summarise(across(everything(), function(x) sum(is.na(x))))

model_data <- base_df%>%
   na.roughfix()%>%
   filter(if_all(everything(), is.finite))
```


```{r linear forest funcs}
library(rsample)
library(purrr)
library(partykit)
library(sandwich)


library(randomForest)
```


```{r tree tools}

MSE <- function(true, pred){
  mean((true - pred)**2, na.rm = TRUE)
}
```

```{r modeling}
train_df <- model_data%>%
  slice_sample(prop = 0.70)

test_df  <- model_data%>%
  anti_join(train_df)

form <- conf_case ~ N1 + N2 | . - N1 - N2
#form <- conf_case ~ N1 | . - N1 - N2
forest_model <- random_linear_forest(data = na.roughfix(train_df),
                                     num_tree = 100, 
                                     model_formula = form,
                                     max_depth = Inf,
                                     verbose = TRUE)


library(profvis)

#profvis({random_linear_forest(data = na.roughfix(train_df),
#                                     num_tree = 24, 
#                                     model_formula = form,
#                                     max_depth = 3,
#                                     verbose = TRUE)})
```

```{r}
pred <- predict(forest_model, test_df)

MSE(pred, test_df$conf_case)

#look into pred being conservitive
test_df%>%
  ggplot(aes(x = pred, 
             y = conf_case - pred))+
  geom_point()


#get better viz tools
#compare tree vs linear tree
#viz 1 tree -> viz forest
#forest viz
library(plyr)
library(dplyr)
inc_MSE <- gen_INCMSE(forest_model)
#reran model
#or 
inc_MSE%>%
  ggplot(aes(y = var, x = incMSE))+
  geom_bar(stat="identity")


summary(forest_model)
```

```{r lm model}
lm_model <- lm(conf_case ~ N1 + N2, data = train_df)
pred <- predict(lm_model, test_df)
MSE(pred, test_df$conf_case)

test_df%>%
  ggplot(aes(x = pred, y = conf_case - predict(lm_model, test_df)))+
  geom_point()
```


```{r testing}
temp <- OOB_MSE_num_trees(forest_model)

temp%>%
  ggplot(aes(y = model_MSE, x = num_tree))+
  geom_line()
```


```{r graph lm_tree}

library(plotly)

plot_lmTree <- function(lmtree_obj){
  plot(lmtree_obj)
  nodes <- as.character(c(3:4,6:7))
  point_plot <- data.frame()
  mx_model <- data.frame()
  for(i in 1:length(nodes)){
    indx <- nodes[i]
    new_data <- data_party(lmtree_obj[[as.numeric(indx)]])%>%
      mutate(model = indx)%>%
      mutate(N1 = N1 + N2)
    ###
    new_model <- coef(lmtree_obj[[as.numeric(indx)]])%>%
      as.data.frame()%>%
      transpose()%>%
      as.data.frame()
    names(new_model) <- c("intercept", "N1", "N2")
    mx_model <- new_model%>%
      mutate(model = indx)%>%
      mutate(N1 = (N1 + N2) / 2)%>%
      bind_rows(mx_model)
    
    ####
    point_plot <- new_data%>%
      bind_rows(point_plot)
  }
  tree_plot <- ggplot() + 
    geom_point(data = point_plot, aes(x = N1, y = conf_case,
                                      color = model))+
    geom_abline(data = mx_model,
                aes(intercept = intercept,
                    slope = N1,
                    color = model))
  return(tree_plot)
}
lapply(1:5, function(x) ggplotly(plot_lmTree(forest_model@models[[x]])))
#ggplotly(plot_lmTree(forest_model@models[[4]]))


#make it 3d :(
```


```{r 3d plot}
plotly_plot_lmTree <- function(lmtree_obj){
  plot(lmtree_obj)
  nodes <- as.character(c(3:4,6:7))
  tree_plot <- plot_ly()
  for(i in 1:length(nodes)){
    indx <- nodes[i]
    model_lab <- paste0("model", indx)
    new_data <- data_party(lmtree_obj[[as.numeric(indx)]])%>%
      mutate(model = model_lab)
    ###
    new_model <- coef(lmtree_obj[[as.numeric(indx)]])%>%
      as.data.frame()%>%
      transpose()%>%
      as.data.frame()
    
    names(new_model) <- c("intercept", "N1", "N2")
    
    
    axis_x <- range(new_data$N1)
    axis_y <- range(new_data$N2)
    lm_DF <- expand.grid(N1 = axis_x,N2 = axis_y,KEEP.OUT.ATTRS = F)%>%
            mutate(conf_case = N1 * new_model$N1 
                     + N2 * new_model$N2 + new_model$intercept)%>%
        pivot_wider(names_from = N1, values_from = conf_case) %>% 
        select(-1) %>%  # kick the name's column out
        as.matrix()
    
    ####
    tree_plot <- tree_plot%>%
      add_trace(data = new_data,
                x = ~N1,
                y = ~N2,
                z = ~conf_case,
                #color = model_lab,
                legendgroup = model_lab,
                type = "scatter3d",
                mode = "markers")%>%
       add_surface(p = .,
                   data = lm_DF,
                 x = axis_x,
                 y = axis_y,
                 z = lm_DF,
                 legendgroup = model_lab,
                 type = "surface",
                 showscale = FALSE)
    
  }
  return(tree_plot)
}
lapply(1:5, function(x) ggplotly(plotly_plot_lmTree(forest_model@models[[x]])))
```